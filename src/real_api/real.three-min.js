export class RealAPI{constructor(e,t,s,n,r={}){this.appKey=t,this.product=n,this.userName=e,this.appSecret=s,this.serverParams=r,this.jobInfo={jobs:[],scene:null},this.waiting=!1,this.connecting=!1,this.isLoggedIn=!1,this.__socket=null}updateJobs(e){if(!e||!e.length)return;const t=this.jobInfo.jobs,s=t.length,n=[];for(const r of e){let e=!0;for(let n=0;n<s;n++){const s=t[n].jobID;if(r.jobID===s){t[n]=r,e=!1;break}}e&&n.push(r)}for(const e of n)t.push(e);this.jobInfo.jobs=t}downloadParams(e){return{data:{jobID:e,prodCred:{appKey:this.appKey,userName:this.userName,appSecret:this.appSecret,prodKey:this.product.prodKey,insID:this.product.insID}}}}async login(e,t){this.__socket?await this.__socket.connect():(this.__socket=new RealSocket(e,t,this),await this.__socket.connect())}async askService(e,t=null){await this.__socket.ask(e,t)}getURI(){const e=this.serverParams,t=e.port?e.port:8010;return`${e.server?e.server:"localhost"}:${t}`}}export class JobResult{constructor(e){this.jobID=e,this.status="",this.result=""}}export class RealProduct{constructor(e,t,s){this.insID=s,this.prodKey=t,this.prodName=e}}import{BufferAttribute,ClampToEdgeWrapping,DoubleSide,InterpolateDiscrete,InterpolateLinear,LinearEncoding,LinearFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,MathUtils,Matrix4,MirroredRepeatWrapping,NearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,PropertyBinding,RGBAFormat,RepeatWrapping,Scene,Source,sRGBEncoding,Vector3}from"./three.module.js";class GLTFExporter{constructor(){this.pluginCallbacks=[],this.register(function(e){return new GLTFLightExtension(e)}),this.register(function(e){return new GLTFMaterialsUnlitExtension(e)}),this.register(function(e){return new GLTFMaterialsTransmissionExtension(e)}),this.register(function(e){return new GLTFMaterialsVolumeExtension(e)}),this.register(function(e){return new GLTFMaterialsClearcoatExtension(e)}),this.register(function(e){return new GLTFMaterialsIridescenceExtension(e)})}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){const r=new GLTFWriter,i=[];for(let e=0,t=this.pluginCallbacks.length;e<t;e++)i.push(this.pluginCallbacks[e](r));r.setPlugins(i),r.write(e,t,n).catch(s)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,n,r,t)})}}export const WEBGL_CONSTANTS={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497};export const THREE_TO_WEBGL={};THREE_TO_WEBGL[NearestFilter]=WEBGL_CONSTANTS.NEAREST,THREE_TO_WEBGL[NearestMipmapNearestFilter]=WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,THREE_TO_WEBGL[NearestMipmapLinearFilter]=WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,THREE_TO_WEBGL[LinearFilter]=WEBGL_CONSTANTS.LINEAR,THREE_TO_WEBGL[LinearMipmapNearestFilter]=WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,THREE_TO_WEBGL[LinearMipmapLinearFilter]=WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR,THREE_TO_WEBGL[ClampToEdgeWrapping]=WEBGL_CONSTANTS.CLAMP_TO_EDGE,THREE_TO_WEBGL[RepeatWrapping]=WEBGL_CONSTANTS.REPEAT,THREE_TO_WEBGL[MirroredRepeatWrapping]=WEBGL_CONSTANTS.MIRRORED_REPEAT;export const PATH_PROPERTIES={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};export const GLB_HEADER_BYTES=12;export const GLB_HEADER_MAGIC=1179937895;export const GLB_VERSION=2;export const GLB_CHUNK_PREFIX_BYTES=8;export const GLB_CHUNK_TYPE_JSON=1313821514;export const GLB_CHUNK_TYPE_BIN=5130562;function equalArray(e,t){return e.length===t.length&&e.every(function(e,s){return e===t[s]})}function stringToArrayBuffer(e){return(new TextEncoder).encode(e).buffer}function isIdentityMatrix(e){return equalArray(e.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function getMinMax(e,t,s){const n={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let r=t;r<t+s;r++)for(let t=0;t<e.itemSize;t++){let s;e.itemSize>4?s=e.array[r*e.itemSize+t]:(0===t?s=e.getX(r):1===t?s=e.getY(r):2===t?s=e.getZ(r):3===t&&(s=e.getW(r)),!0===e.normalized&&(s=MathUtils.normalize(s,e.array))),n.min[t]=Math.min(n.min[t],s),n.max[t]=Math.max(n.max[t],s)}return n}function getPaddedBufferSize(e){return 4*Math.ceil(e/4)}function getPaddedArrayBuffer(e,t=0){const s=getPaddedBufferSize(e.byteLength);if(s!==e.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(e)),0!==t)for(let r=e.byteLength;r<s;r++)n[r]=t;return n.buffer}return e}function getCanvas(){return"undefined"==typeof document&&"undefined"!=typeof OffscreenCanvas?new OffscreenCanvas(1,1):document.createElement("canvas")}function getToBlobPromise(e,t){if(void 0!==e.toBlob)return new Promise(s=>e.toBlob(s,t));let s;return"image/jpeg"===t?s=.92:"image/webp"===t&&(s=.8),e.convertToBlob({type:t,quality:s})}class GLTFWriter{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,s={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},s),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const n=this.buffers,r=this.json;s=this.options;const i=this.extensionsUsed,a=new Blob(n,{type:"application/octet-stream"}),o=Object.keys(i);if(o.length>0&&(r.extensionsUsed=o),r.buffers&&r.buffers.length>0&&(r.buffers[0].byteLength=a.size),!0===s.binary){const e=new FileReader;e.readAsArrayBuffer(a),e.onloadend=function(){const s=getPaddedArrayBuffer(e.result),n=new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));n.setUint32(0,s.byteLength,!0),n.setUint32(4,GLB_CHUNK_TYPE_BIN,!0);const i=getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(r)),32),a=new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));a.setUint32(0,i.byteLength,!0),a.setUint32(4,GLB_CHUNK_TYPE_JSON,!0);const o=new ArrayBuffer(GLB_HEADER_BYTES),c=new DataView(o);c.setUint32(0,GLB_HEADER_MAGIC,!0),c.setUint32(4,GLB_VERSION,!0);const l=GLB_HEADER_BYTES+a.byteLength+i.byteLength+n.byteLength+s.byteLength;c.setUint32(8,l,!0);const u=new Blob([o,a,i,n,s],{type:"application/octet-stream"}),h=new FileReader;h.readAsArrayBuffer(u),h.onloadend=function(){t(h.result)}}}else if(r.buffers&&r.buffers.length>0){const e=new FileReader;e.readAsDataURL(a),e.onloadend=function(){const s=e.result;r.buffers[0].uri=s,t(r)}}else t(r)}serializeUserData(e,t){if(0===Object.keys(e.userData).length)return;const s=this.options,n=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(s.includeCustomExtensions&&r.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(const e in r.gltfExtensions)t.extensions[e]=r.gltfExtensions[e],n[e]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(t){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}getUID(e,t=!1){if(!1===this.uids.has(e)){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const t=new Vector3;for(let s=0,n=e.count;s<n;s++)if(Math.abs(t.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const s=e.clone(),n=new Vector3;for(let e=0,t=s.count;e<t;e++)n.fromBufferAttribute(s,e),0===n.x&&0===n.y&&0===n.z?n.setX(1):n.normalize(),s.setXYZ(e,n.x,n.y,n.z);return t.attributesNormalized.set(e,s),s}applyTextureTransform(e,t){let s=!1;const n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),s=!0),0!==t.rotation&&(n.rotation=t.rotation,s=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),s=!0),s&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=n,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function s(e){return e.encoding===sRGBEncoding?function(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}:function(e){return e}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const n=e.image,r=t.image,i=Math.max(n.width||0,r.width||0),a=Math.max(n.height||0,r.height||0),o=getCanvas();o.width=i,o.height=a;const c=o.getContext("2d");c.fillStyle="#00ffff",c.fillRect(0,0,i,a);const l=c.getImageData(0,0,i,a);if(n){c.drawImage(n,0,0,i,a);const t=s(e),r=c.getImageData(0,0,i,a).data;for(let e=2;e<r.length;e+=4)l.data[e]=256*t(r[e]/256)}if(r){c.drawImage(r,0,0,i,a);const e=s(t),n=c.getImageData(0,0,i,a).data;for(let t=1;t<n.length;t+=4)l.data[t]=256*e(n[t]/256)}c.putImageData(l,0,0);const u=(e||t).clone();return u.source=new Source(o),u.encoding=LinearEncoding,u}processBuffer(e){const t=this.json,s=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),s.push(e),0}processBufferView(e,t,s,n,r){const i=this.json;let a;i.bufferViews||(i.bufferViews=[]),a=t===WEBGL_CONSTANTS.UNSIGNED_BYTE?1:t===WEBGL_CONSTANTS.UNSIGNED_SHORT?2:4;const o=getPaddedBufferSize(n*e.itemSize*a),c=new DataView(new ArrayBuffer(o));let l=0;for(let r=s;r<s+n;r++)for(let s=0;s<e.itemSize;s++){let n;e.itemSize>4?n=e.array[r*e.itemSize+s]:(0===s?n=e.getX(r):1===s?n=e.getY(r):2===s?n=e.getZ(r):3===s&&(n=e.getW(r)),!0===e.normalized&&(n=MathUtils.normalize(n,e.array))),t===WEBGL_CONSTANTS.FLOAT?c.setFloat32(l,n,!0):t===WEBGL_CONSTANTS.UNSIGNED_INT?c.setUint32(l,n,!0):t===WEBGL_CONSTANTS.UNSIGNED_SHORT?c.setUint16(l,n,!0):t===WEBGL_CONSTANTS.UNSIGNED_BYTE&&c.setUint8(l,n),l+=a}const u={buffer:this.processBuffer(c.buffer),byteOffset:this.byteOffset,byteLength:o};return void 0!==r&&(u.target=r),r===WEBGL_CONSTANTS.ARRAY_BUFFER&&(u.byteStride=e.itemSize*a),this.byteOffset+=o,i.bufferViews.push(u),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,s=t.json;return s.bufferViews||(s.bufferViews=[]),new Promise(function(n){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const e=getPaddedArrayBuffer(r.result),i={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,n(s.bufferViews.push(i)-1)}})}processAccessor(e,t,s,n){const r=this.json;let i;if(e.array.constructor===Float32Array)i=WEBGL_CONSTANTS.FLOAT;else if(e.array.constructor===Uint32Array)i=WEBGL_CONSTANTS.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)i=WEBGL_CONSTANTS.UNSIGNED_SHORT;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");i=WEBGL_CONSTANTS.UNSIGNED_BYTE}if(void 0===s&&(s=0),void 0===n&&(n=e.count),0===n)return null;const a=getMinMax(e,s,n);let o;void 0!==t&&(o=e===t.index?WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER:WEBGL_CONSTANTS.ARRAY_BUFFER);const c=this.processBufferView(e,i,s,n,o),l={bufferView:c.id,byteOffset:c.byteOffset,componentType:i,count:n,max:a.max,min:a.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return!0===e.normalized&&(l.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(l)-1}processImage(e,t,s,n="image/png"){if(null!==e){const r=this,i=r.cache,a=r.json,o=r.options,c=r.pending;i.images.has(e)||i.images.set(e,{});const l=i.images.get(e),u=n+":flipY/"+s.toString();if(void 0!==l[u])return l[u];a.images||(a.images=[]);const h={mimeType:n},p=getCanvas();p.width=Math.min(e.width,o.maxTextureSize),p.height=Math.min(e.height,o.maxTextureSize);const m=p.getContext("2d");if(!0===s&&(m.translate(0,p.height),m.scale(1,-1)),void 0!==e.data){t!==RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>o.maxTextureSize||e.height>o.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const s=new Uint8ClampedArray(e.height*e.width*4);for(let t=0;t<s.length;t+=4)s[t+0]=e.data[t+0],s[t+1]=e.data[t+1],s[t+2]=e.data[t+2],s[t+3]=e.data[t+3];m.putImageData(new ImageData(s,e.width,e.height),0,0)}else m.drawImage(e,0,0,p.width,p.height);!0===o.binary?c.push(getToBlobPromise(p,n).then(e=>r.processBufferViewImage(e)).then(e=>{h.bufferView=e})):void 0!==p.toDataURL?h.uri=p.toDataURL(n):c.push(getToBlobPromise(p,n).then(e=>(new FileReader).readAsDataURL(e)).then(e=>{h.uri=e}));const f=a.images.push(h)-1;return l[u]=f,f}throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const s={magFilter:THREE_TO_WEBGL[e.magFilter],minFilter:THREE_TO_WEBGL[e.minFilter],wrapS:THREE_TO_WEBGL[e.wrapS],wrapT:THREE_TO_WEBGL[e.wrapT]};return t.samplers.push(s)-1}processTexture(e){const t=this.cache,s=this.json;if(t.textures.has(e))return t.textures.get(e);s.textures||(s.textures=[]);let n=e.userData.mimeType;"image/webp"===n&&(n="image/png");const r={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,n)};e.name&&(r.name=e.name),this._invokeAll(function(t){t.writeTexture&&t.writeTexture(e,r)});const i=s.textures.push(r)-1;return t.textures.set(e,i),i}processMaterial(e){const t=this.cache,s=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;s.materials||(s.materials=[]);const n={pbrMetallicRoughness:{}};!0!==e.isMeshStandardMaterial&&!0!==e.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(equalArray(r,[1,1,1,1])||(n.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(n.pbrMetallicRoughness.metallicFactor=e.metalness,n.pbrMetallicRoughness.roughnessFactor=e.roughness):(n.pbrMetallicRoughness.metallicFactor=.5,n.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const t=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),s={index:this.processTexture(t)};this.applyTextureTransform(s,t),n.pbrMetallicRoughness.metallicRoughnessTexture=s}if(e.map){const t={index:this.processTexture(e.map)};this.applyTextureTransform(t,e.map),n.pbrMetallicRoughness.baseColorTexture=t}if(e.emissive){const t=e.emissive.clone().multiplyScalar(e.emissiveIntensity),s=Math.max(t.r,t.g,t.b);if(s>1&&(t.multiplyScalar(1/s),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),s>0&&(n.emissiveFactor=t.toArray()),e.emissiveMap){const t={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(t,e.emissiveMap),n.emissiveTexture=t}}if(e.normalMap){const t={index:this.processTexture(e.normalMap)};e.normalScale&&1!==e.normalScale.x&&(t.scale=e.normalScale.x),this.applyTextureTransform(t,e.normalMap),n.normalTexture=t}if(e.aoMap){const t={index:this.processTexture(e.aoMap),texCoord:1};1!==e.aoMapIntensity&&(t.strength=e.aoMapIntensity),this.applyTextureTransform(t,e.aoMap),n.occlusionTexture=t}e.transparent?n.alphaMode="BLEND":e.alphaTest>0&&(n.alphaMode="MASK",n.alphaCutoff=e.alphaTest),e.side===DoubleSide&&(n.doubleSided=!0),""!==e.name&&(n.name=e.name),this.serializeUserData(e,n),this._invokeAll(function(t){t.writeMaterial&&t.writeMaterial(e,n)});const i=s.materials.push(n)-1;return t.materials.set(e,i),i}processMesh(e){const t=this.cache,s=this.json,n=[e.geometry.uuid];if(Array.isArray(e.material))for(let t=0,s=e.material.length;t<s;t++)n.push(e.material[t].uuid);else n.push(e.material.uuid);const r=n.join(":");if(t.meshes.has(r))return t.meshes.get(r);const i=e.geometry;let a;a=e.isLineSegments?WEBGL_CONSTANTS.LINES:e.isLineLoop?WEBGL_CONSTANTS.LINE_LOOP:e.isLine?WEBGL_CONSTANTS.LINE_STRIP:e.isPoints?WEBGL_CONSTANTS.POINTS:e.material.wireframe?WEBGL_CONSTANTS.LINES:WEBGL_CONSTANTS.TRIANGLES;const o={},c={},l=[],u=[],h={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=i.getAttribute("normal");void 0===p||this.isNormalizedNormalAttribute(p)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let m=null;for(let e in i.attributes){if("morph"===e.slice(0,5))continue;const s=i.attributes[e];if(e=h[e]||e.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e)||(e="_"+e),t.attributes.has(this.getUID(s))){c[e]=t.attributes.get(this.getUID(s));continue}m=null;const n=s.array;"JOINTS_0"!==e||n instanceof Uint16Array||n instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),m=new BufferAttribute(new Uint16Array(n),s.itemSize,s.normalized));const r=this.processAccessor(m||s,i);null!==r&&(c[e]=r,t.attributes.set(this.getUID(s),r))}if(void 0!==p&&i.setAttribute("normal",p),0===Object.keys(c).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){const s=[],n=[],r={};if(void 0!==e.morphTargetDictionary)for(const t in e.morphTargetDictionary)r[e.morphTargetDictionary[t]]=t;for(let a=0;a<e.morphTargetInfluences.length;++a){const o={};let c=!1;for(const e in i.morphAttributes){if("position"!==e&&"normal"!==e){c||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),c=!0);continue}const s=i.morphAttributes[e][a],n=e.toUpperCase(),r=i.attributes[e];if(t.attributes.has(this.getUID(s,!0))){o[n]=t.attributes.get(this.getUID(s,!0));continue}const l=s.clone();if(!i.morphTargetsRelative)for(let e=0,t=s.count;e<t;e++)for(let t=0;t<s.itemSize;t++)0===t&&l.setX(e,s.getX(e)-r.getX(e)),1===t&&l.setY(e,s.getY(e)-r.getY(e)),2===t&&l.setZ(e,s.getZ(e)-r.getZ(e)),3===t&&l.setW(e,s.getW(e)-r.getW(e));o[n]=this.processAccessor(l,i),t.attributes.set(this.getUID(r,!0),o[n])}u.push(o),s.push(e.morphTargetInfluences[a]),void 0!==e.morphTargetDictionary&&n.push(r[a])}o.weights=s,n.length>0&&(o.extras={},o.extras.targetNames=n)}const f=Array.isArray(e.material);if(f&&0===i.groups.length)return null;const g=f?e.material:[e.material],d=f?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let e=0,s=d.length;e<s;e++){const s={mode:a,attributes:c};if(this.serializeUserData(i,s),u.length>0&&(s.targets=u),null!==i.index){let n=this.getUID(i.index);void 0===d[e].start&&void 0===d[e].count||(n+=":"+d[e].start+":"+d[e].count),t.attributes.has(n)?s.indices=t.attributes.get(n):(s.indices=this.processAccessor(i.index,i,d[e].start,d[e].count),t.attributes.set(n,s.indices)),null===s.indices&&delete s.indices}const n=this.processMaterial(g[d[e].materialIndex]);null!==n&&(s.material=n),l.push(s)}o.primitives=l,s.meshes||(s.meshes=[]),this._invokeAll(function(t){t.writeMesh&&t.writeMesh(e,o)});const T=s.meshes.push(o)-1;return t.meshes.set(r,T),T}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const s=e.isOrthographicCamera,n={type:s?"orthographic":"perspective"};return s?n.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:n.perspective={aspectRatio:e.aspect,yfov:MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},""!==e.name&&(n.name=e.type),t.cameras.push(n)-1}processAnimation(e,t){const s=this.json,n=this.nodeMap;s.animations||(s.animations=[]);const r=(e=GLTFExporter.Utils.mergeMorphTargetTracks(e.clone(),t)).tracks,i=[],a=[];for(let e=0;e<r.length;++e){const s=r[e],o=PropertyBinding.parseTrackName(s.name);let c=PropertyBinding.findNode(t,o.nodeName);const l=PATH_PROPERTIES[o.propertyName];if("bones"===o.objectName&&(c=!0===c.isSkinnedMesh?c.skeleton.getBoneByName(o.objectIndex):void 0),!c||!l)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',s.name),null;const u=1;let h,p=s.values.length/s.times.length;l===PATH_PROPERTIES.morphTargetInfluences&&(p/=c.morphTargetInfluences.length),!0===s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(h="CUBICSPLINE",p/=3):h=s.getInterpolation()===InterpolateDiscrete?"STEP":"LINEAR",a.push({input:this.processAccessor(new BufferAttribute(s.times,u)),output:this.processAccessor(new BufferAttribute(s.values,p)),interpolation:h}),i.push({sampler:a.length-1,target:{node:n.get(c),path:l}})}return s.animations.push({name:e.name||"clip_"+s.animations.length,samplers:a,channels:i}),s.animations.length-1}processSkin(e){const t=this.json,s=this.nodeMap,n=t.nodes[s.get(e)],r=e.skeleton;if(void 0===r)return null;const i=e.skeleton.bones[0];if(void 0===i)return null;const a=[],o=new Float32Array(16*r.bones.length),c=new Matrix4;for(let t=0;t<r.bones.length;++t)a.push(s.get(r.bones[t])),c.copy(r.boneInverses[t]),c.multiply(e.bindMatrix).toArray(o,16*t);return void 0===t.skins&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new BufferAttribute(o,16)),joints:a,skeleton:s.get(i)}),n.skin=t.skins.length-1}processNode(e){const t=this.json,s=this.options,n=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(s.trs){const t=e.quaternion.toArray(),s=e.position.toArray(),n=e.scale.toArray();equalArray(t,[0,0,0,1])||(r.rotation=t),equalArray(s,[0,0,0])||(r.translation=s),equalArray(n,[1,1,1])||(r.scale=n)}else e.matrixAutoUpdate&&e.updateMatrix(),!1===isIdentityMatrix(e.matrix)&&(r.matrix=e.matrix.elements);if(""!==e.name&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const t=this.processMesh(e);null!==t&&(r.mesh=t)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];if(r.visible||!1===s.onlyVisible){const e=this.processNode(r);null!==e&&t.push(e)}}t.length>0&&(r.children=t)}this._invokeAll(function(t){t.writeNode&&t.writeNode(e,r)});const i=t.nodes.push(r)-1;return n.set(e,i),i}processScene(e){const t=this.json,s=this.options;t.scenes||(t.scenes=[],t.scene=0);const n={};""!==e.name&&(n.name=e.name),t.scenes.push(n);const r=[];for(let t=0,n=e.children.length;t<n;t++){const n=e.children[t];if(n.visible||!1===s.onlyVisible){const e=this.processNode(n);null!==e&&r.push(e)}}r.length>0&&(n.nodes=r),this.serializeUserData(e,n)}processObjects(e){const t=new Scene;t.name="AuxScene";for(let s=0;s<e.length;s++)t.children.push(e[s]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(t){t.beforeParse&&t.beforeParse(e)});const s=[];for(let t=0;t<e.length;t++)e[t]instanceof Scene?this.processScene(e[t]):s.push(e[t]);s.length>0&&this.processObjects(s);for(let e=0;e<this.skins.length;++e)this.processSkin(this.skins[e]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll(function(t){t.afterParse&&t.afterParse(e)})}_invokeAll(e){for(let t=0,s=this.plugins.length;t<s;t++)e(this.plugins[t])}}class GLTFLightExtension{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const s=this.writer,n=s.json,r=s.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,i.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(n.extensions=n.extensions||{},n.extensions[this.name]={lights:[]},r[this.name]=!0);const a=n.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}class GLTFMaterialsUnlitExtension{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class GLTFMaterialsClearcoatExtension{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const t={index:s.processTexture(e.clearcoatMap)};s.applyTextureTransform(t,e.clearcoatMap),r.clearcoatTexture=t}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const t={index:s.processTexture(e.clearcoatRoughnessMap)};s.applyTextureTransform(t,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=t}if(e.clearcoatNormalMap){const t={index:s.processTexture(e.clearcoatNormalMap)};s.applyTextureTransform(t,e.clearcoatNormalMap),r.clearcoatNormalTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class GLTFMaterialsIridescenceExtension{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const t={index:s.processTexture(e.iridescenceMap)};s.applyTextureTransform(t,e.iridescenceMap),r.iridescenceTexture=t}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const t={index:s.processTexture(e.iridescenceThicknessMap)};s.applyTextureTransform(t,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class GLTFMaterialsTransmissionExtension{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const t={index:s.processTexture(e.transmissionMap)};s.applyTextureTransform(t,e.transmissionMap),r.transmissionTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class GLTFMaterialsVolumeExtension{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const t={index:s.processTexture(e.thicknessMap)};s.applyTextureTransform(t,e.thicknessMap),r.thicknessTexture=t}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}GLTFExporter.Utils={insertKeyframe:function(e,t){const s=e.getValueSize(),n=new e.TimeBufferType(e.times.length+1),r=new e.ValueBufferType(e.values.length+s),i=e.createInterpolant(new e.ValueBufferType(s));let a;if(0===e.times.length){n[0]=t;for(let e=0;e<s;e++)r[e]=0;a=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<.001)return 0;n[0]=t,n.set(e.times,1),r.set(i.evaluate(t),0),r.set(e.values,s),a=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<.001)return e.times.length-1;n[n.length-1]=t,n.set(e.times,0),r.set(e.values,0),r.set(i.evaluate(t),e.values.length),a=n.length-1}else for(let o=0;o<e.times.length;o++){if(Math.abs(e.times[o]-t)<.001)return o;if(e.times[o]<t&&e.times[o+1]>t){n.set(e.times.slice(0,o+1),0),n[o+1]=t,n.set(e.times.slice(o+1),o+2),r.set(e.values.slice(0,(o+1)*s),0),r.set(i.evaluate(t),(o+1)*s),r.set(e.values.slice((o+1)*s),(o+2)*s),a=o+1;break}}return e.times=n,e.values=r,a},mergeMorphTargetTracks:function(e,t){const s=[],n={},r=e.tracks;for(let e=0;e<r.length;++e){let i=r[e];const a=PropertyBinding.parseTrackName(i.name),o=PropertyBinding.findNode(t,a.nodeName);if("morphTargetInfluences"!==a.propertyName||void 0===a.propertyIndex){s.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),(i=i.clone()).setInterpolation(InterpolateLinear)}const c=o.morphTargetInfluences.length,l=o.morphTargetDictionary[a.propertyIndex];if(void 0===l)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let u;if(void 0===n[o.uuid]){const e=new((u=i.clone()).ValueBufferType)(c*u.times.length);for(let t=0;t<u.times.length;t++)e[t*c+l]=u.values[t];u.name=(a.nodeName||"")+".morphTargetInfluences",u.values=e,n[o.uuid]=u,s.push(u);continue}const h=i.createInterpolant(new i.ValueBufferType(1));u=n[o.uuid];for(let e=0;e<u.times.length;e++)u.values[e*c+l]=h.evaluate(u.times[e]);for(let e=0;e<i.times.length;e++){const t=this.insertKeyframe(u,i.times[e]);u.values[t*c+l]=i.values[e]}}return e.tracks=s,e}};export{GLTFExporter};export const Status={None:0,Echo:1,Jobs:2,Login:3,Logout:4,NewJob:5,Upload:6,Result:7,Export:8,Occupied:9,Download:10,JobFailed:11,NoRenderer:12,LoginIssue:13,DataFailed:14,LoginFailed:15,SceneFailed:16};export function EnumString(e,t=0){for(let s in Status)if(Status[s]===e)return 0===t?s.toLowerCase():1===t?s.toUpperCase():s;return""}export const ResponseType={Code:0,Binary:1,Json:2};export function RealDeType(e){switch(e){case"echo":return Status.Echo;case"jobs":return Status.Jobs;case"result":return Status.Result;case"newjob":return Status.NewJob;case"upload":return Status.Upload;case"logged_in":return Status.Login;case"login_error":return Status.LoginIssue;case"login_failed":return Status.LoginFailed;default:return Status.None}}export function RealDecoder(e){switch(e){case 0:return Status.LoginIssue;case 1:return Status.LoginFailed;case 2:return Status.Login;case 3:return Status.DataFailed;case 4:return Status.Echo;case 5:return Status.NoRenderer;case 6:return Status.Occupied;default:return Status.None}}export function CheckType(e){return isNaN(e)?e.toString().startsWith("{")?ResponseType.Json:ResponseType.Binary:ResponseType.Code}export function CheckResponseType(e){return isNaN(e)?ResponseType.Json:ResponseType.Code}export class RealResponse{constructor(e=Status.None,t="",s=null){this.msg=t,this.data=s,this.type=e}}export class RealSocket{constructor(e,t,s){this.realAPI=s,this.__url=GetURI(s),this.__error=t,this.__callback=e,this.socket=null,this.instance=null,this.waiting=!1,this.connected=!1}async connect(){this.connected||this.waiting||(this.socket=new WebSocket(this.__url),this.init())}init(){this.socket.onopen=this.open.bind(this),this.socket.onerror=this.error.bind(this),this.socket.onclose=this.closed.bind(this),this.socket.onmessage=this.receive.bind(this)}async receive(e){const t=e.data;await RealUpdater(this,t)}async invoke(e){await this.__callback&&this.__callback(e,this.realAPI)}connectionEstablished(){this.waiting=!1,this.connected=!0,this.realAPI.connecting=!1,this.realAPI.isLoggedIn=!0,cancelAnimationFrame(this.instance)}waitForConnection(){setTimeout(async()=>{await this.ask(Status.Echo),this.instance=requestAnimationFrame(this.waitForConnection.bind(this))},5)}async ask(e,t=null){const s={type:EnumString(e),data:t},n=JSON.stringify(s);this.socket.send(n)}open(e){this.waiting=!0,this.connected=!1,this.realAPI.isLoggedIn=!1}error(e){this.__error&&this.__error()}closed(){this.waiting=!1,this.connected=!1,this.realAPI.isLoggedIn=!1}close(){this.socket.close(),this.closed()}}export function GetURI(e){const t=e.appKey,s=e.product,n=e.userName,r=e.appSecret,i=e.serverParams,a=i.port?i.port:8001;return`${`wss://${i.server?i.server:"localhost"}:${a}/`}login=${`userName=${n}&appKey=${t}&appSecret=${r}`}&${`prodName=${s.prodName}&prodKey=${s.prodKey}&insID=${s.insID}`}`}export const ConvertStatus={FAILED:0,SUCCESS:1,ALREADY:2,NOT_LOGGED:3};export async function SetRealScene(e,t,s){return e.isLoggedIn?e.waiting?ConvertStatus.ALREADY:void await parseScene(e,t,s):ConvertStatus.NOT_LOGGED}async function parseScene(e,t,s){e.waiting=!0;const n=s.name,r=s.parent;r===t||(t.add(s),s.name="RealEYE");(new GLTFExporter).parse(t,async i=>{resetScene(r,n,t,s),await exportDone(e,i)},i=>{resetScene(r,n,t,s),e.waiting=!1,exportError(i)},{binary:!0})}async function exportDone(e,t){const s=GetBin(t);e.jobInfo.scene=s}function resetScene(e,t,s,n){e?e.add(n):s.remove(n),n.name=t}function exportError(e){console.log("An error happened"),console.error(e)}export const LoginStatus={JOB:0,USER:1,SUCCESS:2,ALREADY:3};export async function LoginRealAPI(e,t,s){return e.isLoggedIn?LoginStatus.ALREADY:e.connecting?LoginStatus.JOB:e.__socket&&e.__socket.waiting?LoginStatus.USER:(await e.login(t,s),LoginStatus.SUCCESS)}export function GetBin(e){return new Blob([e],{type:"application/octet-stream"})}export async function blob2uint(e){return new Response(e).arrayBuffer().then(e=>[...new Uint8Array(e)])}export function save(e,t){const s=document.createElement("a");s.href=window.URL.createObjectURL(e),s.download=t,s.click()}export function ConsoleSize(e){const t=`${(e/1024).toFixed(2)} KB`;console.log(t)}export function ConsoleSceneSize(e){ConsoleSize(e.byteLength)}export async function RealUpdater(e,t){const s=UserResponse(t),n=(s.msg,s.data);switch(s.type){case Status.None:return;case Status.Login:return e.realAPI.jobInfo=n,void e.waitForConnection();case Status.Upload:return;case Status.Echo:e.connectionEstablished(),s.type=Status.Login,s.msg="SUCCESS"}await e.invoke(s)}function UserResponse(e){const t=CheckType(e),s=new RealResponse;switch(t){case ResponseType.Code:const n=parseInt(e);return s.type=RealDecoder(n),s.msg=n,s;case ResponseType.Binary:return s.type=Status.Download,s.msg="SUCCESS",s.data=GetBin(e),s;default:const r=JSON.parse(e);return s.msg=r.msg,s.type=ToStatus(r.type),s.data=r.data,s}}function ToStatus(e){switch(CheckResponseType(e)){case ResponseType.Code:return RealDecoder(parseInt(e));default:return RealDeType(e)}}